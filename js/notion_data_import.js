const { Client } = require("@notionhq/client")
const fs = require("fs").promises
const path = require("path")
require("dotenv").config({ path: path.join(__dirname, "../.env") })

const Notion = new Client({ 
  auth: process.env.NOTION_TOKEN
})

const colors = {
  reset: "\x1b[0m",
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m"
}

const OUTPUT_MODES = {
  NEWLINE: 'newline',
  SAMELINE: 'sameline', 
  PROGRESS: 'progress'
}

const DATABASES = {
  ANIME_TITLES_DB: "174d30fa35d081fb8baccf7e405d5cf9",
  ANIME_RELEASES_DB: "174d30fa35d081278dcdf4335e149330",
  TEAMS_DB: "174d30fa35d081c4968cc340c89e4667"
}

process.stdout.setEncoding('utf8')
if (process.stdout.isTTY) {
  process.stdout.setNoDelay(true)
}

function colorLog(message, color = 'reset', mode = OUTPUT_MODES.NEWLINE) {
  const coloredMessage = `${colors[color]}${message}${colors.reset}`
  
  switch(mode) {
    case OUTPUT_MODES.SAMELINE:
      process.stdout.write(`\r${coloredMessage}`)
      break
    case OUTPUT_MODES.PROGRESS:
      process.stdout.write(`${coloredMessage}\n`)
      break
    case OUTPUT_MODES.NEWLINE:
    default:
      process.stdout.write(`${coloredMessage}\n`)
  }
}

async function loadPreviousData(fileName) {
  try {
    const filePath = path.join(__dirname, "../../CPRcatalog/json", fileName)
    const data = JSON.parse(await fs.readFile(filePath, "utf8"))
    colorLog(`–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ –¥–∞–Ω—ñ –∑ ${fileName}: ${data.length} –∑–∞–ø–∏—Å—ñ–≤`, 'blue')
    return data
  } catch (error) {
    colorLog(`–ü–æ–ø–µ—Ä–µ–¥–Ω—ñ –¥–∞–Ω—ñ –∑ ${fileName} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –∞–±–æ –ø–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è: ${error.message}`, 'yellow')
    return []
  }
}

async function saveData(fileName, data) {
  try {
    const targetDir = path.join(__dirname, '../../CPRcatalog/json')
    await fs.mkdir(targetDir, { recursive: true })
    await fs.writeFile(
      path.join(targetDir, fileName),
      JSON.stringify(data, null, 2)
    )
    colorLog(`–£—Å–ø—ñ—à–Ω–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ –¥–∞–Ω—ñ —É —Ñ–∞–π–ª ${fileName}: ${data.length} –∑–∞–ø–∏—Å—ñ–≤`, 'green')
  } catch (error) {
    colorLog(`–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—ñ –¥–∞–Ω–∏—Ö —É —Ñ–∞–π–ª ${fileName}: ${error.message}`, 'red')
    throw error
  }
}

async function getPageById(pageId) {
  try {
    return await Notion.pages.retrieve({ page_id: pageId })
  } catch (error) {
    console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ –¥–∞–Ω–∏—Ö:', error)
    throw error
  }
}

async function getAllPages(databaseId, dbTitle) {
  let pages = []
  let hasMore = true
  let nextCursor = null
  let totalProcessed = 0
  
  console.log(`–ü–æ—á–∞—Ç–æ–∫ —ñ–º–ø–æ—Ä—Ç—É —Å—Ç–æ—Ä—ñ–Ω–æ–∫ –∑ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö ${dbTitle}`)

  while (hasMore) {
    const response = await Notion.databases.query({
      database_id: databaseId,
      start_cursor: nextCursor || undefined
    })

    const newPages = response.results
    totalProcessed += newPages.length
    colorLog(`–û—Ç—Ä–∏–º–∞–Ω–æ ${totalProcessed} —Å—Ç–æ—Ä—ñ–Ω–æ–∫...`, 'reset', OUTPUT_MODES.PROGRESS)
    
    pages = pages.concat(response.results)
    hasMore = response.has_more
    nextCursor = response.next_cursor
  }
  
  colorLog(`\n–ó–∞–≤–µ—Ä—à–µ–Ω–æ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω–æ–∫. –í—Å—å–æ–≥–æ: ${totalProcessed}`, 'reset')
  return pages
}

function filterModifiedPages(allPages, existingData) {
  const existingMap = new Map(
    existingData.map(item => [
      item.id, 
      new Date(item.last_edited || item.created_time || 0)
    ])
  )
  
  const modifiedPages = []
  const newPages = []
  
  for (const page of allPages) {
    const pageId = page.id
    const pageLastEdited = new Date(page.last_edited_time)
    
    if (!existingMap.has(pageId)) {
      newPages.push(page)
      modifiedPages.push(page)
    } else {
      const existingLastEdited = existingMap.get(pageId)
      
      if (pageLastEdited > existingLastEdited || 
          Math.abs(pageLastEdited - existingLastEdited) > 1000) {
        modifiedPages.push(page)
      }
    }
  }
  
  if (newPages.length > 0) {
    colorLog(`–ù–æ–≤–∏—Ö —Å—Ç–æ—Ä—ñ–Ω–æ–∫: ${newPages.length}`, 'green')
  }
  
  if (modifiedPages.length > newPages.length) {
    colorLog(`–ó–º—ñ–Ω–µ–Ω–∏—Ö —ñ—Å–Ω—É—é—á–∏—Ö —Å—Ç–æ—Ä—ñ–Ω–æ–∫: ${modifiedPages.length - newPages.length}`, 'yellow')
  }
  
  return modifiedPages
}

function buildAnimeData(page) {
  return {
    id: page.id,
    hikka_url: page.properties.Hikka?.url,
    cover: page.cover?.external?.url || page.cover?.file?.url,
    title: page.properties['–ù–∞–∑–≤–∞ —Ç–∞–π—Ç–ª—É'].title[0]?.plain_text,
    romaji: page.properties.–†–æ–º–∞–¥–∂—ñ.rich_text[0]?.plain_text,
    synonyms: page.properties.–°–∏–Ω–æ–Ω—ñ–º–∏.rich_text?.flatMap(i => i.plain_text.split('\n')),
    type: page.properties['–¢–∏–ø –º–µ–¥—ñ–∞'].multi_select[0]?.name,
    format: page.properties['–§–æ—Ä–º–∞—Ç'].select?.name,
    format_cpr: page.properties['–§–æ—Ä–º–∞—Ç —Ü–ø—Ä'].select?.name,
    year: page.properties['–†—ñ–∫ –≤–∏—Ö–æ–¥—É'].rich_text[0]?.plain_text,
    genre: page.properties.–ñ–∞–Ω—Ä–∏.select?.name,
    anitube: page.properties.–ê–Ω—ñ–¢—é–±.url,
    uaserial: page.properties.Uaserial.url,
    uakino: page.properties.Uakino.url,
    tg_channel: page.properties['Tg –∫–∞–Ω–∞–ª'].url,
    episodes: page.properties['–ö—ñ–ª—å–∫—ñ—Å—Ç—å —Å–µ—Ä—ñ–π'].rich_text[0]?.plain_text,
    releases: page.properties['üóÇÔ∏è –†–µ–ª—ñ–∑–∏ –∫–æ–º–∞–Ω–¥'].relation || [],
    relations: page.properties["–ü–æ–≤'—è–∑–∞–Ω—ñ —á–∞—Å—Ç–∏–Ω–∏"].relation || [],
    franchise: page.properties.–§—Ä–∞–Ω—à–∏–∑–∞.relation.id || [],
    created_time: page.created_time,
    last_edited: page.last_edited_time
  }
}

async function processAnimeData(pages) {
  const results = []
  
  for (const page of pages) {
    const newAnimeData = buildAnimeData(page)
    results.push(newAnimeData)
  }
  
  return results
}

function hasNewTorrentLinks(currentLinks, previousLinks) {
  const previousUrls = new Set((previousLinks || []).map(link => link.href))
  return currentLinks.some(link => !previousUrls.has(link.href))
}

function buildReleaseData(page, previousRelease) {
  const currentEpisodes = page.properties['–ö—ñ–ª—å–∫—ñ—Å—Ç—å'].rich_text[0]?.plain_text || null
  const currentTorrentLinks = page.properties['–¢–æ—Ä–µ–Ω—Ç –ø–æ—Å–∏–ª–∞–Ω–Ω—è'].rich_text
    .filter(link => link !== null)
    .map(link => ({
      text: link.plain_text.trim(),
      href: link.href
    })) || []

  const previousTorrentLinks = previousRelease?.torrentLinks || []
  const hasNewLinks = hasNewTorrentLinks(currentTorrentLinks, previousTorrentLinks)

  return {
    id: page.id,
    title: page.properties['–ù–∞–∑–≤–∞ —Ä–µ–ª—ñ–∑—É'].title[0]?.plain_text,
    animeIds: page.properties['–¢–∞–π—Ç–ª']?.relation.map(rel => rel.id),
    teams: page.properties['–ö–æ–º–∞–Ω–¥–∞']?.relation.map(rel => rel.id),
    teamscolab: page.properties['–°–ø—ñ–ª—å–Ω–æ –∑']?.relation.map(rel => rel.id),
    dubinfo: page.properties['–û–∑–≤—É—á–∫–∞'].multi_select.flatMap(sel => sel.name) || '–ù–µ –≤–∫–∞–∑–∞–Ω–æ',
    subinfo: page.properties['–°–∞–±–∏'].multi_select.flatMap(sel => sel.name) || '–ù–µ –≤–∫–∞–∑–∞–Ω–æ',
    status: page.properties['–°—Ç–∞—Ç—É—Å'].status?.name || '–ù–µ–≤—ñ–¥–æ–º–æ',
    episodes: currentEpisodes,
    episodessub: page.properties['–ö—ñ–ª—å–∫—ñ—Å—Ç—å —Å—É–±'].rich_text[0]?.plain_text || null,
    wereWatch: page.properties['–î–∏–≤–∏—Ç–∏—Å—å'].multi_select.map(ms => ({ name: ms.name, color: ms.color })) || '–ù–µ –≤–∫–∞–∑–∞–Ω–æ',
    torrentLinks: currentTorrentLinks,
    fexlink: page.properties['FEX –ø–æ—Å–∏–ª–∞–Ω–Ω—è']?.url,
    sitelink: page.properties['–ù–∞ —Å–∞–π—Ç—ñ']?.url,
    problems: page.properties['–ü—Ä–æ–±–ª–µ–º–∏']?.multi_select,
    created_time: page.created_time,
    last_edited: page.last_edited_time,
    episodesLastUpdate: previousRelease && previousRelease.episodes !== currentEpisodes
      ? new Date().toISOString()
      : previousRelease?.episodesLastUpdate || null,
    torrentLinksLastAdded: hasNewLinks
      ? new Date().toISOString() 
      : previousRelease?.torrentLinksLastAdded || null
  }
}

async function processReleaseData(pages) {
  const previousData = await loadPreviousData("AnimeReleasesDB.json")
  const previousDataMap = new Map(previousData.map(release => [release.id, release]))
  
  const results = []
  for (const page of pages) {
    const previousRelease = previousDataMap.get(page.id)
    const newReleaseData = buildReleaseData(page, previousRelease)
    results.push(newReleaseData)
  }
  return results
}

function buildTeamReleases(teamsData, releasesData) {
  colorLog("–§–æ—Ä–º—É–≤–∞–Ω–Ω—è –∑–≤'—è–∑–∫—ñ–≤ —Ä–µ–ª—ñ–∑—ñ–≤ –¥–ª—è –∫–æ–º–∞–Ω–¥...", 'blue')
  
  const teamsMap = new Map(teamsData.map(team => [team.id, team]))
  
  for (const release of releasesData) {
    const releaseInfo = { id: release.id }
    
    if (release.teams && Array.isArray(release.teams)) {
      for (const team of release.teams) {
        if (team.id && teamsMap.has(team.id)) {
          const teamData = teamsMap.get(team.id)
          if (!teamData.anime_releases) {
            teamData.anime_releases = []
          }
          if (!teamData.anime_releases.some(r => r.id === release.id)) {
            teamData.anime_releases.push(releaseInfo)
          }
        }
      }
    }
    
    if (release.teamscolab && Array.isArray(release.teamscolab)) {
      for (const team of release.teamscolab) {
        if (team.id && teamsMap.has(team.id)) {
          const teamData = teamsMap.get(team.id)
          if (!teamData.anime_releases) {
            teamData.anime_releases = []
          }
          if (!teamData.anime_releases.some(r => r.id === release.id)) {
            teamData.anime_releases.push(releaseInfo)
          }
        }
      }
    }
  }
  
  colorLog(`–°—Ñ–æ—Ä–º–æ–≤–∞–Ω–æ –∑–≤'—è–∑–∫–∏ —Ä–µ–ª—ñ–∑—ñ–≤ –¥–ª—è ${teamsData.length} –∫–æ–º–∞–Ω–¥`, 'green')
  return teamsData
}

function buildTeamData(page) {
  return {
    id: page.id,
    cover: page.cover,
    logo: page.icon?.external?.url || page.icon?.file?.url,
    name: page.properties['–ù–∞–∑–≤–∞ –∫–æ–º–∞–Ω–¥–∏']?.title[0]?.plain_text || '–ù–µ–≤—ñ–¥–æ–º–æ',
    altname: page.properties['–°–∏–Ω–æ–Ω—ñ–º–∏'].rich_text?.flatMap(i => i.plain_text.split('\n')),
    founded: page.properties['–î–∞—Ç–∞ –∑–∞—Å–Ω—É–≤–∞–Ω–Ω—è'].date,
    type_team: page.properties['–¢–∏–ø –∫–æ–º–∞–Ω–¥–∏'].multi_select.map(item => item.name) || [],
    type_activity: page.properties['–¢–∏–ø —Ä–æ–±–æ—Ç–∏'].multi_select.map(item => item.name) || [],
    status: page.properties.–°—Ç–∞—Ç—É—Å.select?.name || '–ù–µ–≤—ñ–¥–æ–º–æ',
    members: page.properties['–°–∫–ª–∞–¥ –∫–æ–º–∞–Ω–¥–∏'].relation || [],
    anime_releases: [],
    site: page.properties.–°–∞–π—Ç?.url,
    anitube: page.properties.AniTube?.url,
    youtube: page.properties.YouTube?.url,
    insta: page.properties.Instagram?.url,
    tiktok: page.properties.TikTok?.url,
    tg: page.properties.Telegram?.url,
    tg_video: page.properties['–¢–ì —Ä–µ–ª—ñ–∑–∏']?.url,
    created_time: page.created_time,
    last_edited: page.last_edited_time
  }
}

async function processTeamData(pages, releasesData = []) {
  const results = []
  
  for (const page of pages) {
    const newTeamData = buildTeamData(page)
    results.push(newTeamData)
  }
  
  if (releasesData && releasesData.length > 0) {
    return buildTeamReleases(results, releasesData)
  }
  
  return results
}

function mergeData(existingData, newData) {
  const merged = new Map()
  
  existingData.forEach(item => merged.set(item.id, item))
  newData.forEach(item => merged.set(item.id, item))
  
  return Array.from(merged.values())
}

async function importDatabase(databaseId, dbTitle, outputFileName, processFunction, additionalData = null, onlyModified = true) {
  console.log(`–ü–æ—á–∞—Ç–æ–∫ —ñ–º–ø–æ—Ä—Ç—É –¥–∞–Ω–∏—Ö –¥–ª—è ${outputFileName}...`)
  
  try {
    const existingData = await loadPreviousData(outputFileName)
    const allPages = await getAllPages(databaseId, dbTitle)
    
    let pagesToProcess = allPages
    
    if (onlyModified) {
      pagesToProcess = filterModifiedPages(allPages, existingData)
      colorLog(`–ó–Ω–∞–π–¥–µ–Ω–æ ${pagesToProcess.length} –∑–º—ñ–Ω–µ–Ω–∏—Ö —Å—Ç–æ—Ä—ñ–Ω–æ–∫ –∑ ${allPages.length} –∑–∞–≥–∞–ª—å–Ω–∏—Ö`, 'blue')
    } else {
      colorLog(`–û–±—Ä–æ–±–ª—è—î–º–æ –≤—Å—ñ ${allPages.length} —Å—Ç–æ—Ä—ñ–Ω–æ–∫ (–ø–æ–≤–Ω–∏–π —Ä–µ–∂–∏–º)`, 'blue')
    }
    
    if (pagesToProcess.length === 0) {
      colorLog(`–ù–µ–º–∞—î –∑–º—ñ–Ω–µ–Ω–∏—Ö –¥–∞–Ω–∏—Ö –¥–ª—è ${outputFileName}. –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è.`, 'green')
      return existingData
    }
    
    const newData = await processFunction(pagesToProcess, additionalData)
    const processedData = mergeData(existingData, newData)

    await saveData(outputFileName, processedData)
    colorLog(`–Ü–º–ø–æ—Ä—Ç –¥–∞–Ω–∏—Ö –¥–ª—è ${outputFileName} —É—Å–ø—ñ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –û–Ω–æ–≤–ª–µ–Ω–æ ${pagesToProcess.length} –∑–∞–ø–∏—Å—ñ–≤.`, 'green')
    
    return processedData
  } catch (error) {
    colorLog(`–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —ñ–º–ø–æ—Ä—Ç—ñ –¥–∞–Ω–∏—Ö –¥–ª—è ${outputFileName}: ${error.message}`, 'red')
    throw error
  }
}

async function getAnimeTitlesJson(onlyModified = true) {
  return await importDatabase(
    DATABASES.ANIME_TITLES_DB,
    "–ê–Ω—ñ–º–µ —Ç–∞–π—Ç–ª–∏",
    "AnimeTitlesDB.json",
    processAnimeData,
    null,
    onlyModified
  )
}

async function getReleasesJson(onlyModified = true) {
  return await importDatabase(
    DATABASES.ANIME_RELEASES_DB,
    "–ê–Ω—ñ–º–µ —Ä–µ–ª—ñ–∑–∏",
    "AnimeReleasesDB.json",
    processReleaseData,
    null,
    onlyModified
  )
}

async function getTeamsJson(releasesData, onlyModified = true) {
  return await importDatabase(
    DATABASES.TEAMS_DB,
    "–ö–æ–º–∞–Ω–¥–∏ —Ñ–∞–Ω–¥–∞–±—É",
    "TeamsDB.json",
    processTeamData,
    releasesData,
    onlyModified
  )
}

async function runAllImports(onlyModified = true) {
  try {
    colorLog(`–ó–∞–ø—É—Å–∫ —ñ–º–ø–æ—Ä—Ç—ñ–≤ –≤ —Ä–µ–∂–∏–º—ñ: ${onlyModified ? '—Ç—ñ–ª—å–∫–∏ –∑–º—ñ–Ω–µ–Ω—ñ' : '–ø–æ–≤–Ω–∏–π'}`, 'blue')

    await getAnimeTitlesJson(onlyModified)
    const releasesData = await getReleasesJson(onlyModified)
    // await getTeamsJson(releasesData, onlyModified)
    
    colorLog("–í—Å—ñ —ñ–º–ø–æ—Ä—Ç–∏ —É—Å–ø—ñ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!", 'green')
  } catch (error) {
    colorLog(`–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —ñ–º–ø–æ—Ä—Ç—ñ–≤: ${error.message}`, 'red')
    throw error
  }
}

;(async () => {
  try {
    await runAllImports()
  } catch (err) {
    console.error(err)
    process.exit(1)
  }
})()
